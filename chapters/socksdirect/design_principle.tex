\section{Design Principles}
\label{socksdirect:sec:architecture}

To address the above challenges, we propose the following principles to guide \sys design:

\parab{Consider processes as a distributed system.}
To achieve multi-core and multi-server scalability, we take the Multikernel~\cite{baumann2009multikernel} philosophy and use message passing for inter-process communication to avoid state sharing and synchronization. We consider processes in a server as a distributed system, in the sense that a) processes share nothing but peer-to-peer communication channels, b) new processes may join at any time, c) a process may crash unexpectedly and d) no user process is trusted in terms of security. 
%Instead of relying on the isolation between application and ``protected kernel code'' to maintain security, we delegate privileged operations to a special \textit{monitor} process, analogous to the coordinator in a distributed system.

%We strive to minimize the number of messages to reduce overhead. 
To reduce message passing, in Table~\ref{socksdirect:tab:socket-api}, we categorize Linux socket operations into three categories: local, peer-to-peer and non-partitionable. An operation is \textit{local} if it only changes states local to a process (\textit{e.g.}, assigning file descriptors). An operation is \textit{peer-to-peer} if the states are written by one processes and read by another process (\textit{e.g.} sending a message).
We design all peer-to-peer operations to be non-blocking using shared memory queue, \textit{i.e.} returns immediately after writing to the queue. 
Local and peer-to-peer operations are naturally scalable because their states are partitionable~\cite{partitionable}. For \textit{non-partitionable} and privileged operations (\textit{e.g.}, \texttt{fork} and shared memory allocation), \sys revisits the idea of~\cite{hoare1974monitors} and delegates coordination to a \emph{monitor proces}, which is analogous to the coordinator in a distributed system. Such delegation not only has higher throughput than synchronization~\cite{roghanchi2017ffwd}, but also ensures security and fairness.

\parab{Optimize for the common and prepare for the worst.}
Because sockets can be shared among threads and processes, using mutual exclusion to ensure correctness for concurrent access would sacrifice the common-case one-to-one communication performance. To avoid such synchronization overhead, we create a queue between each pair of sender and receiver processes, and ensures receive ordering and liveness (Sec.\ref{socksdirect:subsec:fork}).

To reduce context switch and scheduling overhead, observing the access pattern of most event-driven applications, we use cooperative multitasking and polling to reduce inter-core interrupts, signaling and scheduling costs. When all processes are awake and responsive to incoming messages, the system achieves high performance at the cost of active polling. To reduce polling overhead, \sys puts a process to sleep after being idle for some time. \sys uses Linux signals to interrupt long-running application code and wake up sleeping or blocked processes (Sec.\ref{socksdirect:subsec:process-mux}). 

\parab{Use different transports.} To provide persistent good performance, we choose different transports in different scenarios. As shown in Figure~\ref{socksdirect:fig:architecture}, for intra-server communication, we use shared memory. For inter-server communication inside a data center, we use one-sided RDMA write~\cite{mitchell2013using,kaminsky2016design}. To enable efficient shared memory and RDMA communications, we design a high performance lockless queue, so that each memory location is only written by a single process. This design minimizes cache migration and RDMA messages, as well provides memory isolation among different queues. To amortize polling overhead of infrequently used queues, we use the 网卡 and monitor for event multiplexing (Sec.\ref{socksdirect:subsec:lockless-queue}). As RDMA is only deployed in data centers, we use a user-space TCP/IP stack~\cite{dunkels2001design} to handle Wide Area Network (WAN) traffic. Further, we extend the page remapping technology to achieve zero copy for shared memory, RDMA and TCP (Sec.\ref{socksdirect:subsec:zerocopy}).
