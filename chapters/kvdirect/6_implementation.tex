\section{Implementation}
\label{kvdirect:sec:implementation}



%
%\begin{table}[htbp]
%	\centering
%	\caption{Line of code and resource utilization of the key-value processor.}
%	\label{kvdirect:tab:resource-util}
%	\scalebox{0.8}{
%		\begin{tabular}{l|r|r|r}
%			\toprule
%			Component & LoC & Logic (\%) & Memory (\%) \\
%			\midrule
%            Hash table & & & \\
%            Slab memory allocator & & & \\
%            Dynamic operation scheduler & & & \\
%            DRAM load dispatcher & & & \\
%            Operation decoder & & & \\
%            \midrule
%            Interconnect & & & \\
%            OpenCL runtime & & & \\
%            Network hard IP & & & \\
%            PCIe DMA and hard IP & & & \\
%            DDR controller & & & \\
%            \midrule
%            Total & & & \\
%			\bottomrule
%		\end{tabular}
%	}
%\end{table}

The following discusses several details in the implementation.



\subsection{Slab Memory Allocator}



\subsection{DRAM Load Balancer}

%\textbf{Key-Value Operation Decoder.}
%The key-value operation decoder saves receive timestamp and UDP flow tuple as execution context in reservation station.
%When the key-value operation completes, the flow control component measures the processing delay from the receive timestamp in execution context.
%The network encoder needs the flow tuple to generate completion packets and send to the client.
%To avoid head-of-line blocking, key-value operations are processed out-of-order, so the client may receive key-value completions in a different order from requests.
%The client could match the completions with requests by the key, because completions with a same key are guaranteed to be in request order.
