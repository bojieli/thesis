\chapter{系统架构}

本文提出一个基于可编程网卡的高性能数据中心系统架构。
可编程网卡是服务器与外界通信的 ``网关''，也是服务器内硬件设备、虚拟机间通信的 ``枢纽''。
我们把虚拟化、网络和存储功能、操作系统中需要高性能的数据平面卸载到可编程网卡，以降低 ``数据中心税''，让 CPU 集中精力于客户的应用程序。


\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/virt_arch.pdf}
	\caption{回顾：虚拟化的数据中心架构。}
	\label{arch:fig:virt-architecture}
\end{figure}

第 \ref{chapter:intro} 章已经讨论过，如图 \ref{arch:fig:virt-architecture} 所示，虚拟化的数据中心主要可以分为计算、网络、存储节点。
在网络和存储节点，我们采用控制面与数据面分离的设计思想。数据面是操作相对频繁、逻辑相对简单的处理，而控制面是操作相对不频繁、逻辑相对复杂的处理。我们在可编程网卡中实现数据面，在主机 CPU 上实现控制面，实现了数据面完全不经过主机 CPU。这包括第 \ref{chapter:clicknp} 章的虚拟网络功能和第 \ref{chapter:kvdirect} 章的数据结构处理。加速虚拟网络功能和远程数据结构访问也是本文最重要的创新。

在计算节点，亦即客户虚拟机所在的服务器主机上，我们用可编程网卡实现虚拟机监控器（hypervior）的虚拟化功能和操作系统原语。
虚拟化分为 ``一虚多'' 和 ``多虚一'' 两个方面。
``一虚多''，即可编程网卡把计算节点内的硬件资源虚拟化成多个逻辑资源，实现其他计算节点和本地多台虚拟机的多路复用。例如，第 \ref{chapter:clicknp} 章的 ClickNP 将硬件网卡和网络链路虚拟化为每个虚拟机一张虚拟网卡；第 \ref{chapter:clicknp} 章的 KV-Direct 实现了多个客户端并发访问共享键值存储，并能保证一致性。
``多虚一''，即可编程网卡把数据中心内物理上分散的资源虚拟化成一个逻辑资源，实现逻辑资源到物理资源的映射和路由。例如，第 \ref{chapter:clicknp} 章的 ClickNP 将数据中心内网络功能虚拟化成逻辑上统一的网络功能；第 \ref{chapter:clicknp} 章的 KV-Direct 客户端将分布式键值存储虚拟化成逻辑上统一的键值映射；还可以实现存储和内存的解聚（disaggregation）。
为了加速操作系统原语并控制硬件的复杂度，我们把操作系统原语划分为可编程网卡上的可靠通信协议和主机 CPU 上运行的用户态库、用户态管理程序，如第 \ref{chapter:socksdirect} 章 SocksDirect 实现的套接字通信原语。

图 \ref{arch:fig:accel-arch} 显示了基于可编程网卡的系统总体架构。下面我们将按照网络、存储和高层抽象的顺序，简要介绍本文后续各章的总体设计。


\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/accel_arch.pdf}
	\caption{基于可编程网卡的数据中心系统总体架构。}
	\label{arch:fig:accel-arch}
\end{figure}



\section{网络加速}

\subsection{网络虚拟化加速}

我们从第 \ref{chapter:intro} 章的传统数据中心架构（图 \ref{intro:fig:virt-architecture}）开始，逐步把 ``数据中心税'' 消除或者卸载（offload）到可编程网卡上。
如图 \ref{arch:fig:virtual-network} 所示，第一步是用可编程网卡替代原有的普通网卡，并把软件实现的虚拟网络卸载到可编程网卡上。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/virtual_network.pdf}
	\caption{用可编程网卡加速虚拟网络后的架构。}
	\label{arch:fig:virtual-network}
\end{figure}


为了让虚拟机上的操作系统网络协议栈能够使用虚拟网络收发数据包，可编程网卡利用 SR-IOV（Single Root I/O Virtualization）技术 \cite{dong2012high}，虚拟化成多个 PCIe 虚拟设备（VF，Virtual Function），并给每台虚拟机分配一个 PCIe 虚拟设备。
虚拟机内原有的虚拟网卡驱动程序（如基于 virtio 技术 \cite{russell2008virtio} 的）需要替换为本文实现的 FPGA 驱动程序和基于 FPGA 的虚拟网卡驱动程序。
第 \ref{chapter:clicknp} 章的 ClickNP 将硬件网卡和网络链路虚拟化为多个租户的虚拟网络。

如果我们可以绕过虚拟机操作系统的网络协议栈，直接替换虚拟机上应用程序所使用的标准库（即系统调用接口 libc），就不必实现 SR-IOV 硬件虚拟化。
第 \ref{chapter:socksdirect} 章的 SocksDirect 通过截获应用程序关于网络套接字的标准库调用，在用户态实现了容器覆盖网络（container overlay network），即适用于容器的虚拟网络。
为了用户态运行库与可编程网卡间的高效通信，我们在虚拟机内安装 FPGA 驱动程序，将可编程网卡的 PCIe 地址空间的一部分映射到用户态，从而绕过了虚拟机内核和虚拟机监视器（Virtual Machine Monitor 或 Hypervisor）。



\subsection{网络功能加速}

如图 \ref{arch:fig:network-function} 所示，第二步是在网络节点上，把软件实现的虚拟网络功能划分为数据面和用户面，并把数据面卸载到可编程网卡中。
需要注意的是，网络节点和计算节点的划分是逻辑上的。有可能虚拟网络功能被编排到与虚拟机相同的服务器主机上，这时网络节点和计算节点的功能就合二为一了，虚拟网络和虚拟网络功能之间的连接也从数据中心网络简化成了可编程网卡内模块间的连接。

来自源计算节点（或上一个网络节点）的数据包被网络节点的可编程网卡接收之后，在网卡内的数据面进行处理，大多数情况下不需要打扰 CPU 上的控制面，就可以把处理后的数据包再发送回数据中心网络，到达目的计算节点（或下一个网络节点）。
第 \ref{chapter:clicknp} 章将介绍如何用高级语言模块化编程实现网络功能，实现 FPGA 数据面与 CPU 控制面的协同处理。


\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/NFV_accel.pdf}
	\caption{用可编程网卡加速网络功能后的架构。}
	\label{arch:fig:network-function}
\end{figure}

\section{存储加速}

\subsection{存储虚拟化加速}

在网络加速之后，第三、四步是存储加速。作为第三步，我们首先计算节点的存储虚拟化功能卸载到可编程网卡中。
虚拟机需要两种访问块存储（block storage）的方式：一是通过操作系统的存储协议栈来访问块设备，二是通过用户态的快速接口绕过操作系统直接访问。
由于操作系统本身和很多软件运行在块存储上，保持第一种传统访问方式的兼容性是必要的。
存储性能敏感的应用则使用本文提供的库来通过第二种方式访问块存储。

如图 \ref{arch:fig:virt-storage} 所示，可编程网卡将存储硬件的物理请求队列（如 SATA 的 32 个请求槽位和 NVMe 的请求队列）虚拟化成多个逻辑请求队列，并给第一种访问方式和每个需要第二种访问方式的应用分配一条逻辑请求队列。
由于第一种传统方式仅为提供兼容性，为了降低开发难度，本文没有使用 SR-IOV 技术，而是复用了现有虚拟机监视器中的软件虚拟化方案。
为了提供第二种高效访问方式，我们在虚拟机内安装 FPGA 驱动程序，将逻辑请求队列映射到用户态，从而应用程序可以通过我们的库接口直接访问可编程网卡，绕过了操作系统和虚拟机监控器。

为了支持多个存储节点组成的分布式存储，虚拟云存储服务需要把逻辑地址映射到存储节点地址。例如，在第 \ref{chapter:clicknp} 章的分布式键值存储中，客户端需要根据一致性哈希（consistent hashing） \cite{nishtala2013scaling}，把键（key）映射到存储节点，再把请求路由到该节点。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/virt_storage.pdf}
	\caption{用可编程网卡加速本地存储和云存储后的架构。}
	\label{arch:fig:virt-storage}
\end{figure}

\subsection{数据结构处理加速}

第四步，我们将存储节点上的数据结构处理卸载（offload）到可编程网卡。

数据面是操作相对频繁、逻辑相对简单的处理，而控制面是操作相对不频繁、逻辑相对复杂的处理。我们在可编程网卡中实现数据面，在主机 CPU 上实现控制面，实现了数据面完全不经过主机 CPU。

第 \ref{chapter:clicknp} 章的 KV-Direct 实现了多个客户端并发访问共享键值存储，并能保证一致性

网卡直接访问内存数据结构

直接访问远程硬件资源，而无需经过远程机器的 CPU。

为了解决本地和远程访问同一块存储区域时的一致性问题，不管是本地还是远程访问，都经过可编程网卡处理。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/data_structure_accel.pdf}
	\caption{用可编程网卡加速数据结构处理后的架构。}
	\label{arch:fig:data-structure-accel}
\end{figure}

\section{操作系统加速}

可编程网卡上的可靠通信协议和主机 CPU 上运行的用户态库、用户态管理程序

OS kernel 给应用程序提供的原语可以重构为（控制面）协调和管理（仍在内核或用户态 daemon） + （数据面）用户态 library 负责高层抽象 + （数据面）可编程网卡负责多路复用、调度唤醒和可靠传输等低层语义，需要思考数据面上软硬件的接口（SocksDirect）。

客户应用程序如果可以使用云服务商提供的运行库和驱动程序，可编程网卡就不一定需要支持硬件虚拟化。例如第 \ref{chapter:socksdirect} 章的 SocksDirect 在用户态运行库中实现了套接字，其与网卡间的通信就不需要使用虚拟网卡，而只需与物理网卡建立通信队列。

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/os_primitives_accel.pdf}
	\caption{用可编程网卡加速操作系统通信原语后的架构。}
	\label{arch:fig:os-primitives-accel}
\end{figure}


\section{可编程网卡}



\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.6\textwidth]{figures/sw_hw_codesign.pdf}
	\caption{软硬件协同设计的可编程网卡架构。}
	\label{arch:fig:sw-hw-codesign}
\end{figure}


\subsection{硬件架构}

可编程网卡需要高度灵活性。为什么要 FPGA + CPU + ASIC SoC。回应第二章。

\textbf{图1: 网卡 SoC 结构图}

\subsection{高级语言编程框架}

FPGA 高级语言编程：ClickNP，适合流式处理的模块化 FPGA 高级语言编程

虚拟机热迁移，计算节点对应的网卡状态；网络、存储节点热迁移（升级，扩容等），网卡状态；高可用性，故障恢复……

\subsection{基础服务中间件}



第 \ref{chapter:kvdirect} 章提出的 FPGA 内有状态处理（stateful processing）、数据结构。
第 \ref{chapter:clicknp} 章的有状态网络功能、第 \ref{chapter:kvdirect} 章的内存键值存储、第 \ref{chapter:socksdirect} 章的可扩放 RDMA 的基础。
尽管第 \ref{chapter:clicknp} 章的 ClickNP 在第 \ref{chapter:kvdirect} 章之前发表，发表时的有状态处理和哈希表是使用与应用逻辑耦合紧密的方式实现的，既不容易扩放到大量并发连接，代码的可维护性也不强。
使用第 \ref{chapter:kvdirect} 章的 KV-Direct 作为基础后，这些网络功能的实现将变得模块化和可扩放。

本文使用高级语言编程框架实现基础服务中间件，中间件未来可以硬件化。
