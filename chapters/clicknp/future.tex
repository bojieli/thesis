\section{Future Work}
\label{clicknp:sec:future}

One challenge for deploying ClickNP in production data centers is the 30-second interruption of the data plane while the FPGA is being reprogrammed. The partial reconfiguration \cite{bourgeault2011alteras} feature of the FPGA can be utilized to maintain basic packet forwarding functionality while the FPGA is being reprogrammed.

The on-chip DRAM has a relatively low throughput which is insufficient for rule caching and line-rate packet buffering. This problem can be mitigated if the host memory can be utilized by kernels. Using the existing PCIe streaming interface to access host DRAM incurs high CPU overhead and high latency. In theory, the FPGA should be able to access host DRAM via DMA directly, but the implementation of a random-access DMA engine is left for future work.

OpenCL does not provide a way for explicit pipeline control. We cannot control when and where a large combinational logic is split into pipeline stages. For instance, if we have a data handler that loads from a block SRAM, performs a multiplication operation that takes 3 cycles, then stores the result back to it. The OpenCL scheduler will launch the iteration every 3 cycles due to memory dependency. However, a hardware developer could pipeline the iteration by running three multiplication logics in parallel and re-issuing operations with conflicting addresses -- a well-known technique in superscalar processors and speculative execution.

OpenCL also does not allow explicit specification of an array to be registers or block SRAM. When we need to use a variable to index an array while keeping it as registers instead of block SRAM, we have to use the \textit{.repeat} statement to duplicate many copies of a code snippet.

Furthermore, OpenCL cannot independently figure out accessed memory regions and therefore split them into different memory banks. If we use a two-dimensional array \textit{value[DEPTH][WIDTH]} instead of one single-dimensional array \textit{valueN[WIDTH]} per stage in the \textit{IP\_Checksum} example, all accesses to the two-dimensional array would be considered dependent. A similar problem occurs with struct members. A symbolic execution engine might be able to recognize such virtual memory dependencies and therefore split the array into distinct memory banks.

The text you provided is already in English and in an academic style. As per your instructions, I will keep it as-is:

Although ClickNP offers abstractions and coding conventions to leverage spatial and temporal parallelism, software developers still need to familiarize themselves with these abstractions and programming guidelines to write fully pipelined elements. An alternative approach could involve identifying common coding styles for software programmers who are accustomed to the CPU model, and automatically optimizing the code. This approach is feasible to a certain extent. For instance, even if a loop does not have a constant termination condition, we can still unroll it if the maximum possible iterations can be inferred.
